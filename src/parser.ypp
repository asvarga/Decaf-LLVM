%{
#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>

#include "visitor/ast.cpp"


using namespace std;

extern "C" int yylex();
extern "C" int yyparse();
// extern "C" voIDENTIFIER yyerror(char *s); // lol
extern "C" void yyerror(string s);
extern "C" int yywrap(void){return 1;};

extern "C" void yydebug(string s);

extern FILE *yyin;

StartA* start;


%}


%token      BREAK
%token      CLASS
%token      CONTINUE
%token      ELSE
%token      EXTENDS
%token      IF
%token      NEW
%token<s>   PRIVATE
%token<s>   PROTECTED
%token<s>   PUBLIC
%token<s>   RETURN
%token<s>   STATIC
%token<s>   SUPER
%token<s>   TYPE_VOID
%token<s>   TYPE_INT
%token<s>   TYPE_BOOL
%token<s>   TYPE_CHAR
%token      THIS
%token      WHILE
%token      FORBIDDEN
%token      UNENDED_COM
%token<s>   LEQ
%token<s>   LESS
%token<s>   GREATER
%token<s>   EQEQ
%token<s>   GEQ
%token<s>   EQ
%token<s>   NEQ
%token<s>   LAND
%token<s>   LOR
%token<s>   PLUS
%token<s>   MINUS
%token<s>   TIMES
%token<s>   DIV
%token<s>   MOD
%token<s>   NOT
%token      OP
%token      CP
%token      OB
%token      CB
%token      OC
%token      CC
%token      COMMA
%token      DOT
%token      SEMICOLON
%token<s>   IDENTIFIER
%token      NILL        // TODO:
%token<b>   BOOLEAN
%token<i>   INTEGER
%token<s>   STRING
%token<c>   CHAR
%token      UNRECOG_ERROR
%token      TYPER_INT
%token      VOID

// %precedence NOT
// %left PLUS MINUS TIMES DIV MOD
// %right EQ
// %left LOR LAND
// %left LESS GREATER LEQ GEQ
// %left EQEQ NEQ
// %precedence UMINUS

%precedence NOT UMINUS UPLUS
%left       TIMES DIV MOD
%left       PLUS MINUS
%nonassoc   LESS GREATER LEQ GEQ
%left       EQEQ NEQ
%left       LAND
%left       LOR
%right      EQ
%right      IF
%right      LOWEST

%union{
    char*       s;
    int         i;
    double      d;
    bool        b;
    char        c;

    class AST*          ast;
    class ClassA*       classA;
    class StartA*       startA;
    class ListA*        listA;
    class FieldA*       fieldA;
    class MethodA*      methodA;
    class ConstructorA* constructorA;
    class LitA*         litA;
    class TypeA*        typeA;
    class PrimTypeA*    primTypeA;
    class FormalA*      formalA;
    class BlockA*       blockA;
    class StatementA*   statementA;
    class ExpressionA*  expressionA;
    class VarDeclA*     varDeclA;
    class SuperA*       superA;
    class NewArrayA*    newArrayA;
    class ArrayRefA*    arrayRefA;
    class FieldExprA*   fieldExprA;
}

%type<s>                var_decl_id
%type<i>                bracket_list

%type<ast>              member
%type<classA>           single_class
%type<listA>            member_list modifier_list formal_args formal_arg_list statement_list var_decl_list actual_args expr_list dimension_list
%type<startA>           class_list
%type<fieldA>           field
%type<methodA>          method_decl
%type<constructorA>     ctor
%type<typeA>            type_decl
%type<primTypeA>        primitive_type
%type<formalA>          formal_arg
%type<blockA>           block
%type<statementA>       statement
%type<expressionA>      expr primary non_new_array_expr dimension
%type<varDeclA>         var_decl
%type<litA>             literal modifier
%type<superA>           super
%type<newArrayA>        new_array_expr
%type<arrayRefA>        array_expr
%type<FieldExprA>       field_expr


%%

// TODO: this line helps with syntax coloring for some reason

class_list
    : single_class class_list {
        yydebug(" $$ = $2; $$->addf($1); ");
        $$ = $2; $$->addf($1);
    }
    | single_class {
        yydebug(" $$ = new StartA(); $$->addf($1); ");
        $$ = new StartA(); $$->addf($1);
    }


single_class
    : CLASS IDENTIFIER OC CC {
        yydebug(" $$ = new ClassA($2, new SuperA(new ClassTypeA(\"Object\"))); ");
        $$ = new ClassA($2, new SuperA(new ClassTypeA("Object")));
    }
    | CLASS IDENTIFIER super OC CC {
        yydebug(" $$ = new ClassA($2, $3); ");
        $$ = new ClassA($2, $3);
    }
    | CLASS IDENTIFIER OC member_list CC {
        yydebug(" $$ = new ClassA($2, new SuperA(new ClassTypeA(\"Object\")), $4); ");
        $$ = new ClassA($2, new SuperA(new ClassTypeA("Object")), $4);
    }
    | CLASS IDENTIFIER super OC member_list CC {
        yydebug(" $$ = new ClassA($2, $3, $5); ");
        $$ = new ClassA($2, $3, $5);
    }

super
    : EXTENDS IDENTIFIER {
        yydebug(" $$ = new SuperA($2); ");
        $$ = new SuperA(new ClassTypeA($2));
     }

member_list
    : member member_list {
        yydebug(" $$ = $2; $$->addf($1); ");
        $$ = $2; $$->addf($1);
    }
    | member {
        yydebug(" $$ = new ListA(); $$->addf($1); ");
        $$ = new ListA(); $$->addf($1);
    }

member
    : field {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }
    | method_decl {
        ydebug(" $$ = $1; ");
        $$ = $1;
    }
    | ctor {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }

field
    : modifier_list type_decl var_decl_list SEMICOLON  {
        yydebug(" \\
        $$ = new ListA(); \\
        for(auto const field : $3.getASTs()) \\
        { \\
            $$->addb(new FieldA($1, $2, field)); \\
        }");

        $$ = new ListA();
        for(auto const field : $3.getASTs())
        {
            $$->addb(new FieldA($1, $2, field));
        }


    }
    | type_decl var_decl_list SEMICOLON {
        yydebug(" \\
        $$ = new ListA(); \\
        for(auto const field : $2) \\
        { \\
            $$->addb(new FieldA("public", $1, field)); \\
        }");

        $$ = new ListA();
        for(auto const field : $2)
        {
            $$->addb(new FieldA("public", $1, field));
        }
    }

modifier_list
    : modifier modifier_list {
        yydebug(" $$ = $2; $$->addf($1); ");
        $$ = $2; $$->addf($1);
    }
    | modifier {
        yydebug(" $$ = new ListA(); $$->addf($1); ");
        $$ = new ListA(); $$->addf($1);
    }

method_decl
    : modifier_list type_decl IDENTIFIER formal_args block {
        yydebug(" $$ = new MethodA($1, $2, $3, $4, new MethodBodyA($4, $5->getStatementList())); ");
        $$ = new MethodA($1, $2, $3, $4, new MethodBodyA($4, $5->getStatementList()));
    }
    | type_decl IDENTIFIER formal_args block {
        yydebug(" $$ = new MethodA($1, $2, $3, new MethodBodyA($3, $4->getStatementList())); ");
        $$ = new MethodA($1, $2, $3, new MethodBodyA($3, $4->getStatementList()));
    }

ctor
    : modifier_list IDENTIFIER formal_args block {
        yydebug(" $$ = new ConstructorA(new TypeA($2), $1, new MethodBodyA($3, $4)); ");
        $$ = new ConstructorA(new ClassTypeA($2), $1, new MethodBodyA($3, $4));
    }
    | IDENTIFIER formal_args block {
        yydebug(" $$ = new Constructor(new TypeA($1), new MethodBodyA($2, $3)); ");
        $$ = new Constructor(new ClassTypeA($1), new MethodBodyA($2, $3));
    }

modifier
    : STATIC    {
        yydebug(" $$ = new modifierA("static"); ");
        $$ = new modifierA("static");
    }
    | PUBLIC    {
        yydebug(" $$ = new modifierA("public"); ");
        $$ = new modifierA("public");
    }
    | PRIVATE   {
        yydebug(" $$ = new modifierA("private"); ");
        $$ = new modifierA("private");
    }
    | PROTECTED {
        yydebug(" $$ = new modifierA("protected"); ");
        $$ = new modifierA("protected");
    }

formal_args
    : OP formal_arg_list CP {
        yydebug(" $$ = $2; ");
        $$ = $2;
    }
    | OP CP {
        yydebug(" $$ = new ListA(); ");
        $$ = new ListA();
    }

formal_arg_list
    : formal_arg COMMA formal_arg_list {
        yydebug(" $$ = $3; $$->addf($1); ");
        $$ = $3; $$->addf($1);
    }
    | formal_arg {
        yydebug(" $$ = new ListA(); $$->addf($1); ");
        $$ = new ListA(); $$->addf($1);
    }

formal_arg
    : type_decl var_decl_id {
        yydebug(" $$ = new FormalA($1, $2);");
        $$ = new FormalA($1, $2);
    }

type_decl
    : primitive_type {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }
    | IDENTIFIER {
        yydebug(" $$ = new ClassTypeA($1); ");
        $$ = new ClassTypeA($1);
    }
    | type_decl bracket_list {
        yydebug(" $$ = new ArrayTypeA($1, $2); ");
        $$ = new ArrayTypeA($1, $2);
    }

bracket_list
    : OB CB bracket_list {
        yydebug(" $$ = ++$3; ");
        $$ = ++$3;
    }
    | OB CB {
        yydebug(" $$ = 1; ");
        $$ = 1;
    }

primitive_type
    : TYPE_BOOL {
        yydebug(" $$ = new PrimTypeA(new NameA($1)); ");
        $$ = new PrimTypeA(new NameA($1));
    }
    | TYPE_CHAR {
        yydebug(" $$ = new PrimTypeA(new NameA($1)); ");
        $$ = new PrimTypeA(new NameA($1));
    }
    | TYPE_INT  {
        yydebug(" $$ = new PrimTypeA(new NameA($1)); ");
        $$ = new PrimTypeA(new NameA($1));
    }
    | TYPE_VOID {
        yydebug(" $$ = new PrimTypeA(new NameA($1)); ");
        $$ = new PrimTypeA(new NameA($1));
    }

var_decl_list
    : var_decl COMMA var_decl_list {
        yydebug(" $$ = $3; $$->addf($1); ");
        $$ = $3; $$->addf($1);
    }
    | var_decl {
        yydebug(" $$ = new StartA(); $$->addf($1); ");
        $$ = new ListA(); $$->addf($1);
    }

var_decl
    : var_decl_id EQ expr {
        yydebug(" $$ = new VarDeclA($1, $3); ");
        $$ = new VarDeclA($1, $3);
    }
    | var_decl_id {
        yydebug(" $$ = new VarDeclA($1); ");
        $$ = new VarDeclA($1);
    }

var_decl_id
    : var_decl_id OB CB {
        yyerror(" $$ = $1+\"[]\"; ");
        $$ = $1;
    }
    | IDENTIFIER {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }

block
    : OC statement_list CC {
        yydebug(" $$ = new BlockA($2); ");
            $$ = new BlockA($2);
        }
    | OC CC {
        yydebug(" $$ = new BlockA(); ");
        $$ = new BlockA();
    }

statement_list
    : statement statement_list {
        yydebug(" $$ = $2; $$->addf($1); ");
        $$ = $2; $$->addf($1);
    }
    | statement {
        yydebug(" $$ = new ListA(); $$->addf($1); ");
        $$ = new ListA(); $$->addf($1);
    }

statement
    : SEMICOLON {
        yyerror(" $$ =new EmptyStatement() ");
        new EmptyStatement()
    }
    | type_decl var_decl_list SEMICOLON {
        yydebug(" $$ = new DeclStatementA($1, $2); ");
        $$ = new DeclStatementA($1, $2);
    }
    | IF OP expr CP statement
            %prec LOWEST {
            yyerror(" $$ = new IfStatementA($3, $5, NULL); ");
            $$ = new IfStatementA($3, $5, NULL);
    }
    | IF OP expr CP statement ELSE statement {
        yyerror(" $$ = new IfStatementA($3, $5, $7); ");
        $$ = new IfStatementA($3, $5, $7);
    }
    | expr SEMICOLON {
        yydebug(" $$ = new ExpressionStatementA($1); ");
        $$ = new ExpressionStatementA($1);
    }
    | WHILE OP expr CP statement {
        yyerror(" $$ = new WhileStatement(new symbolTable(), $3, $5); ");
        $$ = new WhileStatement($3, $5);
    }
    | RETURN SEMICOLON {
        yyerror(" $$ = new ReturnStatement(NULL); ");
        $$ = new ReturnStatement(NULL);
    }
    | RETURN expr SEMICOLON {
        yyerror(" $$ = new ReturnStatement($2); ");
        $$ = new ReturnStatement($2);
    }
    | CONTINUE SEMICOLON {
        yyerror(" $$ = new ContinueStatement(); ");
        $$ = new ContinueStatement();
    }
    | BREAK SEMICOLON {
        yyerror(" $$ = new BreakStatement(); ");
        $$ = new BreakStatement();
    }
    | block {
        yyerror(" $$ = new Block($1); ");
        $$ = new BlockStatementA($1);
    }
    | SUPER actual_args SEMICOLON {
        yyerror(" $$ = new SuperStatement($2); ");
        $$ = new SuperStatementA($2)
    }

expr
    : expr EQ expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
        }
    | expr GREATER expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr LESS expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr EQEQ expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr GEQ expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr LEQ expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr NEQ expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr PLUS expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr MINUS expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr TIMES expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr DIV expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr LAND expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr LOR expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | expr MOD expr {
        yydebug(" $$ = new OpExpressionA($2, $1, $3); ");
        $$ = new OpExpressionA($2, $1, $3);
    }
    | PLUS expr %prec UPLUS {
        yydebug(" $$ = new OpExpressionA($1, $2); ");
        $$ = new OpExpressionA($1, $2);
    }
    | MINUS expr %prec UMINUS {
        yydebug(" $$ = new OpExpressionA($1, $2); ");
        $$ = new OpExpressionA($1, $2);
    }
    | NOT expr {
        yydebug(" $$ = new OpExpressionA($1, $2); ");
        $$ = new OpExpressionA($1, $2);
    }
    | primary {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }

primary
    : new_array_expr {
        yyerror(" $$ = $1 ");
        $$ = $1;
    }
    | non_new_array_expr {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }
    | IDENTIFIER {
        yydebug(" $$ = $1; ");
        $$ = new NameA($1);
    }

new_array_expr
    : NEW IDENTIFIER dimension_list {
        yydebug(" new NewArrayA( new NameA($2), $3) ");
        new NewArrayA( new ClassTypeA(new NameA($2)), $3);
    }
    | NEW primitive_type dimension_list {
        yydebug("new newArrayA($2, $3);");
        new NewArrayA($2, $3);
    }

dimension_list
    : dimension dimension_list {
        yydebug(" $1->addf(new DimensionA($1)); $$ = $2; ");
        $1->addf(new DimensionA($1));
        $$ = $2;

    }
    | dimension {
        yydebug("$$ = new ListA(); $$->addf($1); ");
        $$ = new ListA();
        $$->addf(new DimensionA($1));
    }

dimension
    : OP expr CB {
        yydebug(" $$ = $2 ");
        $$ = $2;
    }

non_new_array_expr
    : literal {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }
    | THIS {
        yydebug(" $$ = new ThisExpr(); ");
        $$ = new ThisExpr();
    }
    | OP expr CP {
        yydebug(" $$ = $2; ");
        $$ = $2;
    }
    | NEW IDENTIFIER actual_args {
        yydebug(" $$ = new NewObjExpr(new NameA($2), $3); ");
        $$ = new NewObjExpr(new Name($2), $3);
    }
    | IDENTIFIER actual_args {
        yydebug(" $$ = new ThisCallExpr($1, $2); ");
        $$ = new ThisCallExpr(new NameA($1), $2);
    }
    | primary DOT IDENTIFIER actual_args {
        yydebug(" $$ = new MethodCallExpr($1, $3, $4); ");
        $$ = new MethodCallExpr($1, new NameA($3), $4);
    }
    | SUPER DOT IDENTIFIER actual_args {
        yydebug(" $$ = new SuperCallExpr($3, $4); ");
        $$ = new SuperCallExpr(new NameA($3), $4);
    }
    | array_expr {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }
    | field_expr {
        yydebug(" $$ = $1; ");
        $$ = $1;
    }

field_expr
    : primary DOT IDENTIFIER {
        yydebug(" $$ = new FieldExprA($1, new NameA($3)); ");
        $$ = new FieldExprA($1, new NameA($3));
    }
    | SUPER DOT IDENTIFIER {
        yydebug(" $$ = new SuperfieldExprA(new NameA($3)); ");
        $$ = new SuperfieldExprA(new NameA($3));
    }

array_expr
    : IDENTIFIER dimension {
        yydebug(" $$ = new ArrayRefA(new NameA($1), $2); ");
        $$ = new ArrayRefA(new NameA($1), $2);
    }
    | non_new_array_expr dimension {
        yydebug(" $$ = new ArrayRefA($1, $2); ");
        $$ = new ArrayRefA($1, $2);
    }

literal
    : NILL {
        yyerror(" $$ = new NullLiteral(); ");
        $$ = new NullLitA();
    }
    | BOOLEAN {
        yyerror(" $$ = new BoolLiteral($1); ");
        $$ = new BoolLitA($1);
    }
    | INTEGER {
        yydebug(" $$ = new IntLitA($1); ");
        $$ = new IntLitA($1);
    }
    | CHAR {
        yyerror(" $$ = new CharLiteral($1); ");
        $$ = new CharLiteral($1);
    }
    | STRING {
        yydebug(" $$ = new StrLitA($1); ");
        $$ = new StrLitA($1);
    }

actual_args
    : OP expr_list CP {
        yydebug(" $$ = $2 ");
        $$ = $2;
    }
    | OP CP {
        yydebug(" $$ = {} ");
        $$ = new ListA();
    }

expr_list
    : expr COMMA expr_list {
        yydebug(" $$ = $3; $$->addf($1); ");
        $$ = $3;
        $$->addf($1);
    }
    | expr {
        yydebug(" $$ = new ListA(); $$->addf($1); ");
        $$ = new ListA();
        $$->addf($1);
    }

%%

void yyerror(string s)
{
	// fprintf(stderr, "error: %s\n", s);
    cout << "XXXX error: " << s << " XXXXXXXXXXXXXXXXXXXXXXX\n";
}

void yydebug(string s) {
    // printf("%s", s);
    cout << "\t" << s << "\n";
}

int main(int argc, char **argv) {
    cout << "\n===[PARSING]===\n";

    yyin = fopen(argv[1], "r");
	yyparse();

    cout << "\n===[PRINTING]===\n";
    cout << "\n";
    start->accept(*(new PrinterV()));
    cout << "\n";

    // cout << "\n===[COUNTING]===\n";
    // cout << "\n";
    // start->accept(*(new CounterV()));
    // cout << "\n";

	return 0;
}
