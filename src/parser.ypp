%{
#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>


using namespace std;

extern "C" int yylex();
extern "C" int yyparse();
extern "C" voIDENTIFIER yyerror(char *s);
extern "C" int yywrap(void){return 1;};



%}


%token BREAK
%token CLASS
%token CONTINUE
%token ELSE
%token EXTENDS
%token IF
%token NEW
%token PRIVATE
%token PROTECTED
%token PUBLIC
%token RETURN
%token STATIC
%token SUPER
%token TYPE_VOID
%token TYPE_INT
%token TYPE_BOOL
%token TYPE_CHAR
%token THIS
%token WHILE
%token FORBIDDEN
%token UNENDED_COM
%token LEQ
%token LESS
%token GREATER
%token EQEQ
%token GEQ
%token EQ
%token NEQ
%token LAND
%token LOR
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token NOT
%token OP
%token CP
%token OB
%token CB
%token OC
%token CC
%token COMMA
%token DOT
%token SEMICOLON
%token IDENTIFIER
%token NILL
%token BOOLEAN
%token INTEGER
%token STRING
%token CHAR
%token UNRECOG_ERROR

%precedence NOT
%left ADD SUBS TIMES DIV MOD
%right EQ
%left LOR LAND
%left LESS GREATER LEQ GEQ
%left EQEQ NEQ
%precedence UMINUS

%%
class_list
    : single_class class_list                     { $$->push_back($1); }
    | single_class                               { $$->push_back($1); }
    ;

single_class
    : CLASS IDENTIFIER OC CC                    { $$ = new Class($2, object_class, []); }

    | CLASS IDENTIFIER super OC CC              { $$ = new Class($2, $3, []); }

    | CLASS IDENTIFIER OC member_list CC         { $$ = new Class($2, object_class, $4); }

    | CLASS IDENTIFIER super OC member_list CC   { $$ = new Class($2, $3, $5); }
    ;

super
    : EXTENDS IDENTIFIER                                { $$ = new Super($2) }
    ;

member_list
    : member member_list                         { $$->push_back($1); }
    | member                                    { $$->push_back($1); }
    ;

member
    : field                                     { $$ = $1; }
    | method_decl                                { $$ = $1; }
    | ctor                                      { $$ = $1; }
    ;

field
    : modifier_list type_decl var_decl_list SEMICOLON  { List.map
                                                  (fun d -> Field($1, $2, d))
                                                  $3 }
    | type_decl var_decl_list SEMICOLON               { List.map
                                                  (fun d ->
                                                  Field([Public], $1, d)) $2 }
    ;

modifier_list
    : modifier modifier_list                     { $$->push_back($1); }
    | modifier                                  { $$->push_back($1); }
    ;

method_decl
    : modifier_list type_decl IDENTIFIER formal_args block    { $$->push_back(new Method($3, $2, $1, $4, $5); }
    | type_decl IDENTIFIER formal_args block    { $$->push_back(new Method($2, $1, "public", $3, $4)); }
    ;

ctor
    : modifier_list IDENTIFIER formal_args block          { $$ = new Constructor(new ClassType($2), $1, $3, $4) }
    | IDENTIFIER formal_args block                       { $$ = new Constructor(new ClassType($1), "public", $2, $3); }
    ;

modifier
    : STATIC                                    { $$ = "static" }
    | PUBLIC                                    { $$ = "public" }
    | PRIVATE                                   { $$ = "private" }
    | PROTECTED                                 { $$ = "protected" }
    ;

formal_args
    : OP formal_arg_list CP               { $$ = $2 }
    | OP CP                             { $$ = {} }
    ;

formal_arg_list
    : formal_arg COMMA formal_arg_list             { $$->push_back($1); }
    | formal_arg                                 { $$->push_back($1); }
    ;

formal_arg
    : type_decl var_decl_id
    {
        let declName, declCnt = $2 in
        if declCnt != 0 then
            match $1 with
            | ClassType s ->
                {name = declName; t = ArrayType(ClassType(s), declCnt)}
            | ArrayType (arrayT, c) ->
                {name = declName; t = ArrayType(arrayT, c + declCnt)}
            | BoolType ->
                {name = declName; t = ArrayType(BoolType, declCnt)}
            | CharType ->
                {name = declName; t = ArrayType(CharType, declCnt)}
            | IntType ->
                {name = declName; t = ArrayType(IntType, declCnt)}
            (* TODO should a void type in a formal arg be a parse error? Or
               maybe offload to type checker *)
            | VoIDENTIFIERType ->
                {name = declName; t = ArrayType(VoIDENTIFIERType, declCnt)}
            (* TODO these aren't really parse errors but semantic errors *)
            | MethodType (_, _, _) -> raise Parsing.Parse_error
        else
            {name = declName; t = $1}
    }
    ;

type_decl
    : primitive_type                             { $$ = $1; }
    | IDENTIFIER                                        { $$ = new ClassType($1); }
    | primitive_type bracket_list                 { $$ = new ArrayType($1, $2) }
    | IDENTIFIER bracket_list                            { $$ = new ArrayType(new ClassType($1), $2) }
    ;

bracket_list
    : OB CB bracket_list             { $$ = 1 + $3;}
    | OB CB                         { $$ = 1; }
    ;

primitive_type
    : TYPE_BOOL                                  { new BoolType() }
    | TYPE_CHAR                                  { new CharType() }
    | TYPER_INT                                  { new IntType() }
    | VOID                                       { new Void() }
    ;

var_decl_list
    : var_decl COMMA var_decl_list                 { $$->push_back($1); }
    | var_decl                                   {  $$->push_back($1); }
    ;

var_decl
    : var_decl_id EQ expr                       { { name = fst $1
                                                  ; dim = snd $1
                                                  ; expr = Some $3
                                                  } }
    | var_decl_id                                 { { name = fst $1
                                                  ; dim = snd $1
                                                  ; expr = None
                                                  } }
    ;

var_decl_id
    : var_decl_id OB CB               { fst $1, snd $1 + 1 }
    | IDENTIFIER                                        { $1, 0 }
    ;

block
    : OC statement_list CC               { $$ = $2; }
    | OC CC                             { $$ = {} }
    ;

statement_list
    : statement statement_list                   { $$->push_back($1); }
    | statement                                 { $$->push_back($1); }
    ;

statement
    : SEMICOLON                                 { $$ =new EmptyStatement() }
    | type_decl var_decl_list SEMICOLON         { $$ = new DeclStatement($1, $2) }
    | IF OP expr CP statement
        %prec LOWER_THAN_ELSE                   { $$ = new If($3, $5, NULL); }
    | IF OP expr CP statement ELSE
        statement                               { $$ = new If($3, $5, $7); }
    | expr SEMICOLON                            { $$ = new ExprStatement($1); }
    | WHILE OP expr CP statement        { $$ = new WhileStatement(new symbolTable(), $3, $5); }
    | RETURN SEMICOLON                          { $$ = new ReturnStatement(NULL); }
    | RETURN expr SEMICOLON                     { $$ = new ReturnStatement($2); }
    | CONTINUE SEMICOLON                        { $$ = new ContinueStatement(); }
    | BREAK SEMICOLON                           { $$ = new BreakStatement(); }
    | block                                     { $$ = new Block($1); }
    | SUPER actual_args SEMICOLON                { $$ = new SuperStatement($2); }
    ;

expr
    : expr EQ expr                            {$$ = new BinOpExpr(string($2), $1, $3); }
    | expr GREATER expr                         { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr LESS expr                            { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr EQEQ expr                          { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr GEQ expr                             { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr LEQ expr                             { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr NEQ expr                             { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr PLUS expr                            { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr MINUS expr                           { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr TIMES expr                           { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr DIV expr                             { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr LAND expr                             { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr LOR expr                              { $$ = new BinOpExpr(string($2), $1, $3); }
    | expr MOD expr                             { $$ = new BinOpExpr(string($2), $1, $3); }
    | PLUS expr %prec UPLUS                     { $$ = new UnOpExpr(string($2), $2); }
    | MINUS expr %prec UMINUS                   { $$ = new UnOpExpr(string($2), $2); }
    | NOT expr                                  { $$ = new UnOpExpr(string($2), $2); }
    | primary                                   { $$ = new PrimaryExpr($1); }
    ;

primary
    : new_array_expr                              { $$ = new NewArrayPrimary(
                                                    new defaultTypebox(),
                                                    $1) }
    | non_new_array_expr                           { $$ = new NonNewArrayPrimary(
                                                    new default_typebox(),
                                                    $1) }
    | IDENTIFIER                                        { $$ = new IdPrimary( new defaultTypebox(), $1); }
    ;

new_array_expr
    : NEW IDENTIFIER dimension_list                      { { t = ClassType($2)
                                                  ; dimList = $3
                                                  } }
    | NEW primitive_type dimension_list           { { t = $2
                                                  ; dimList = $3
                                                  }}
    ;

dimension_list
    : dimension dimension_list                   { $$->push_back($1); }
    | dimension                                 { $$->push_back($1); }
    ;

dimension
    : OP expr CB                    { $$ = $2 }
    ;

non_new_array_expr
    : literal                                   { $$ = new LiteralExpr($1) }
    | THIS                                      { $$ = new ThisExpr(); }
    | OP expr CP                        { $$ = new ParenExpr($2); }
    | NEW IDENTIFIER actual_args                         { $$ = new NewObjExpr($2, $3); }
    | IDENTIFIER actual_args                             { $$ = new ThisCallExpr($1, $2); }
    | primary DOT IDENTIFIER actual_args                 { $$ = new MethodCallExpr($1, $3, $4); }
    | SUPER DOT IDENTIFIER actual_args                   { $$ = new SuperCallExpr($3, $4); }
    | array_expr                                 { $$ = $1; }
    | field_expr                                 { $$ = $1; }
    ;

field_expr
    : primary DOT IDENTIFIER                            { $$ = new fieldExpr($1, $3);}
    | SUPER DOT IDENTIFIER                              { $$ = new SuperfieldExpr($3); }
    ;

array_expr
    : IDENTIFIER dimension                              { $$ = new ArrayExpr(new IdPrimary(
                                                    new DefaultTypebox(),
                                                    $1), $2;) }
    | non_new_array_expr dimension                 { $$ = new ArrayExpr(new NonNewArrayPrimary(
                                                    new DefaultTypebox(),
                                                    $1), $2); }
    ;

literal
    : NILL                                          { $$ = new NullLiteral(); }
    | BOOLEAN                                       { $$ = new BoolLiteral($1); }
    | INTEGER                                       { $$ = new IntLiteral($1); }
    | CHAR                                          { $$ = new CharLiteral($1); }
    | STRING                                        { $$ = new StringLiteral($1); }
    ;

actual_args
    : OP expr_list CP                    { $$ = $2 }
    | OP CP                              { $$ = {} }
    ;

expr_list
    : expr COMMA expr_list                       { $$->push_back($1); }
    | expr                                      { $$->push_back($1); }
    ;

%%

void yyerror(char *s)
{
	fprintf(stderr, "error: %s\n", s);
}
