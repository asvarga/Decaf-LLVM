%{
#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>

#include "visitor/ast.cpp"


using namespace std;

extern "C" int yylex();
extern "C" int yyparse();
// extern "C" voIDENTIFIER yyerror(char *s); // lol
extern "C" void yyerror(string s);
extern "C" int yywrap(void){return 1;};

extern "C" void yydebug(string s);

extern FILE *yyin;

StartA* start;


%}


%token      BREAK
%token      CLASS
%token      CONTINUE
%token      ELSE
%token      EXTENDS
%token      IF
%token      NEW
%token<s>   PRIVATE
%token<s>   PROTECTED
%token<s>   PUBLIC
%token<s>   RETURN
%token<s>   STATIC
%token<s>   SUPER
%token<s>   TYPE_VOID
%token<s>   TYPE_INT
%token<s>   TYPE_BOOL
%token<s>   TYPE_CHAR
%token      THIS
%token      WHILE
%token      FORBIDDEN
%token      UNENDED_COM
%token<s>   LEQ
%token<s>   LESS
%token<s>   GREATER
%token<s>   EQEQ
%token<s>   GEQ
%token<s>   EQ
%token<s>   NEQ
%token<s>   LAND
%token<s>   LOR
%token<s>   PLUS
%token<s>   MINUS
%token<s>   TIMES
%token<s>   DIV
%token<s>   MOD
%token<s>   NOT
%token      OP
%token      CP
%token      OB
%token      CB
%token      OC
%token      CC
%token      COMMA
%token      DOT
%token      SEMICOLON
%token<s>   IDENTIFIER
%token      NILL        // TODO:
%token<b>   BOOLEAN
%token<i>   INTEGER
%token<s>   STRING
%token<c>   CHAR
%token      UNRECOG_ERROR
%token      TYPER_INT
%token      VOID

// %precedence NOT
// %left PLUS MINUS TIMES DIV MOD
// %right EQ
// %left LOR LAND
// %left LESS GREATER LEQ GEQ
// %left EQEQ NEQ
// %precedence UMINUS

%precedence NOT UMINUS UPLUS
%left       TIMES DIV MOD
%left       PLUS MINUS
%nonassoc   LESS GREATER LEQ GEQ
%left       EQEQ NEQ
%left       LAND
%left       LOR
%right      EQ
%right      IF
%right      LOWEST

%union{
    char*       s;
    int         i;
    double      d;
    bool        b;
    char        c;

    class AST*          ast;
    class ClassA*       classA;
    class StartA*       startA;
    class ListA*        listA;
    class FieldA*       fieldA;
    class MethodA*      methodA;
    class ConstructorA* constructorA;
    class LitA*         litA;
    class TypeA*        typeA;
    class PrimTypeA*    primTypeA;
    class FormalA*      formalA;
    class BlockA*       blockA;
    class StatementA*   statementA;
    class ExpressionA*  expressionA;
    class VarDeclA*     varDeclA;
}

%type<s>                var_decl_id
%type<i>                bracket_list

%type<ast>              member 
%type<classA>           single_class super
%type<listA>            member_list modifier_list formal_args formal_arg_list statement_list var_decl_list
%type<startA>           class_list
%type<fieldA>           field
%type<methodA>          method_decl
%type<constructorA>     ctor
%type<typeA>            type_decl
%type<primTypeA>        primitive_type
%type<formalA>          formal_arg
%type<blockA>           block
%type<statementA>       statement
%type<expressionA>      expr primary non_new_array_expr
%type<varDeclA>         var_decl
%type<litA>             literal modifier 



%% 

// TODO: this line helps with syntax coloring for some reason

class_list
    : single_class class_list { 
        yydebug(" $$ = $2; $$->addf($1); "); 
        $$ = $2; $$->addf($1);
    }
    | single_class { 
        yydebug(" $$ = new StartA(); $$->addf($1); "); 
        $$ = new StartA(); $$->addf($1);

        start = $$;
    }
    

single_class
    : CLASS IDENTIFIER OC CC { 
        yydebug(" $$ = new ClassA($2); ");
        $$ = new ClassA($2);
    }
    | CLASS IDENTIFIER super OC CC { 
        yydebug(" $$ = new ClassA($2, $3); "); 
        $$ = new ClassA($2, $3);
    }
    | CLASS IDENTIFIER OC member_list CC { 
        yydebug(" $$ = new ClassA($2, $4); "); 
        $$ = new ClassA($2, $4);
    }
    | CLASS IDENTIFIER super OC member_list CC { 
        yydebug(" $$ = new ClassA($2, $3, $5); "); 
        $$ = new ClassA($2, $3, $5);
    }

super
    : EXTENDS IDENTIFIER { yydebug(" $$ = new Super($2) "); }

member_list
    : member member_list { 
        yydebug(" $$ = $2; $$->addf($1); "); 
        $$ = $2; $$->addf($1);
    }
    | member { 
        yydebug(" $$ = new ListA(); $$->addf($1); "); 
        $$ = new ListA(); $$->addf($1);
    }

member
    : field { yydebug(" $$ = $1; "); $$ = $1; }
    | method_decl { yydebug(" $$ = $1; "); $$ = $1; }
    | ctor { yydebug(" $$ = $1; "); $$ = $1; }

field
    : modifier_list type_decl var_decl_list SEMICOLON  { yydebug(" <BLAH> "); } 
    | type_decl var_decl_list SEMICOLON { yydebug(" <BLAH> "); }

modifier_list
    : modifier modifier_list { 
        yydebug(" $$ = $2; $$->addf($1); "); 
        $$ = $2; $$->addf($1);
    }
    | modifier { 
        yydebug(" $$ = new ListA(); $$->addf($1); "); 
        $$ = new ListA(); $$->addf($1);
    }

method_decl
    : modifier_list type_decl IDENTIFIER formal_args block { 
        yydebug(" $$ = new MethodA($1, $2, $3, $4, new MethodBodyA($4, $5->getStatementList())); "); 
        $$ = new MethodA($1, $2, $3, $4, new MethodBodyA($4, $5->getStatementList()));
    }
    | type_decl IDENTIFIER formal_args block { 
        yydebug(" $$ = new MethodA($1, $2, $3, new MethodBodyA($3, $4->getStatementList())); "); 
        $$ = new MethodA($1, $2, $3, new MethodBodyA($3, $4->getStatementList()));
    }

ctor
    : modifier_list IDENTIFIER formal_args block { yydebug(" $$ = new Constructor(new ClassType($2), $1, $3, $4) "); }
    | IDENTIFIER formal_args block { yydebug(" $$ = new Constructor(new ClassType($1), \"public\", $2, $3); "); }

modifier
    : STATIC    { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }
    | PUBLIC    { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }
    | PRIVATE   { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }
    | PROTECTED { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }

formal_args
    : OP formal_arg_list CP { yydebug(" $$ = $2; "); $$ = $2; }
    | OP CP { yydebug(" $$ = new ListA(); "); $$ = new ListA(); }

formal_arg_list
    : formal_arg COMMA formal_arg_list { 
        yydebug(" $$ = $3; $$->addf($1); "); 
        $$ = $3; $$->addf($1);
    }
    | formal_arg { 
        yydebug(" $$ = new ListA(); $$->addf($1); "); 
        $$ = new ListA(); $$->addf($1);
    }

formal_arg
    : type_decl var_decl_id { 
        yydebug(" $$ = new FormalA($1, $2); ?? "); // TODO:
    }

type_decl   
    : primitive_type { 
        yydebug(" $$ = $1; "); 
        $$ = $1;
    }
    | IDENTIFIER { 
        yydebug(" $$ = new ClassTypeA($1); "); 
        $$ = new ClassTypeA($1); 
    }
    | type_decl bracket_list { 
        yydebug(" $$ = new ArrayTypeA($1, $2); "); 
        $$ = new ArrayTypeA($1, $2);
    }

bracket_list
    : OB CB bracket_list { yydebug(" $$ = ++$3; "); $$ = ++$3; }
    | OB CB { yydebug(" $$ = 1; "); $$ = 1; }

primitive_type
    : TYPE_BOOL { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }
    | TYPE_CHAR { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }
    | TYPE_INT  { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }
    | TYPE_VOID { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }

var_decl_list
    : var_decl COMMA var_decl_list { 
        yydebug(" $$ = $3; $$->addf($1); "); 
        $$ = $3; $$->addf($1);
    }
    | var_decl { 
        yydebug(" $$ = new StartA(); $$->addf($1); "); 
        $$ = new ListA(); $$->addf($1);
    }

var_decl
    : var_decl_id EQ expr { yydebug(" $$ = new VarDeclA($1, $3); "); $$ = new VarDeclA($1, $3); }
    | var_decl_id { yydebug(" $$ = new VarDeclA($1); "); $$ = new VarDeclA($1); }

var_decl_id
    : var_decl_id OB CB { yyerror(" $$ = $1+\"[]\"; "); $$ = $1; }
    | IDENTIFIER { yydebug(" $$ = $1; "); $$ = $1; }

block
    : OC statement_list CC { yydebug(" $$ = new BlockA($2); "); $$ = new BlockA($2); }
    | OC CC { yydebug(" $$ = new BlockA(); "); $$ = new BlockA(); }

statement_list
    : statement statement_list { 
        yydebug(" $$ = $2; $$->addf($1); "); 
        $$ = $2; $$->addf($1);
    }
    | statement { 
        yydebug(" $$ = new ListA(); $$->addf($1); "); 
        $$ = new ListA(); $$->addf($1);
    }

statement
    : SEMICOLON { yyerror(" $$ =new EmptyStatement() "); }
    | type_decl var_decl_list SEMICOLON { 
        yydebug(" $$ = new DeclStatementA($1, $2); ");
        $$ = new DeclStatementA($1, $2); 
    }
    | IF OP expr CP statement
            %prec LOWEST { yyerror(" $$ = new If($3, $5, NULL); "); }
    | IF OP expr CP statement ELSE statement { yyerror(" $$ = new If($3, $5, $7); "); }
    | expr SEMICOLON { 
        yydebug(" $$ = new ExpressionStatementA($1); "); 
        $$ = new ExpressionStatementA($1);
    }
    | WHILE OP expr CP statement { yyerror(" $$ = new WhileStatement(new symbolTable(), $3, $5); "); }
    | RETURN SEMICOLON { yyerror(" $$ = new ReturnStatement(NULL); "); }
    | RETURN expr SEMICOLON { yyerror(" $$ = new ReturnStatement($2); "); }
    | CONTINUE SEMICOLON { yyerror(" $$ = new ContinueStatement(); "); }
    | BREAK SEMICOLON { yyerror(" $$ = new BreakStatement(); "); }
    | block { yyerror(" $$ = new Block($1); "); }
    | SUPER actual_args SEMICOLON { yyerror(" $$ = new SuperStatement($2); "); }

expr
    : expr EQ expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr GREATER expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr LESS expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr EQEQ expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr GEQ expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr LEQ expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr NEQ expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr PLUS expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr MINUS expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr TIMES expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr DIV expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr LAND expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr LOR expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | expr MOD expr { yydebug(" $$ = new OpExpressionA($2, $1, $3); "); $$ = new OpExpressionA($2, $1, $3); }
    | PLUS expr %prec UPLUS { yydebug(" $$ = new OpExpressionA($1, $2); "); $$ = new OpExpressionA($1, $2); }
    | MINUS expr %prec UMINUS { yydebug(" $$ = new OpExpressionA($1, $2); "); $$ = new OpExpressionA($1, $2); }
    | NOT expr { yydebug(" $$ = new OpExpressionA($1, $2); "); $$ = new OpExpressionA($1, $2); }
    | primary { yydebug(" $$ = $1; "); $$ = $1; }

primary
    : new_array_expr { yyerror(" $$ = new NewArrayPrimary( new defaultTypebox(), $1) "); }
    | non_new_array_expr { yydebug(" $$ = $1; "); $$ = $1; }
    | IDENTIFIER { yydebug(" $$ = $1; "); $$ = new StrLitA($1); }

new_array_expr
    : NEW IDENTIFIER dimension_list { yydebug("{ t = ClassType($2) ; dimList = $3 }"); }
    | NEW primitive_type dimension_list { yydebug("{ t = $2 ; dimList = $3 }"); }

dimension_list
    : dimension dimension_list { yydebug(" $$->push_back($1); "); }
    | dimension { yydebug(" $$->push_back($1); "); }

dimension
    : OP expr CB { yydebug(" $$ = $2 "); }

non_new_array_expr
    : literal { yydebug(" $$ = $1; "); $$ = $1; }
    | THIS { yydebug(" $$ = new ThisExpr(); "); }
    | OP expr CP { yydebug(" $$ = new ParenExpr($2); "); }
    | NEW IDENTIFIER actual_args { yydebug(" $$ = new NewObjExpr($2, $3); "); }
    | IDENTIFIER actual_args { yydebug(" $$ = new ThisCallExpr($1, $2); "); }
    | primary DOT IDENTIFIER actual_args { yydebug(" $$ = new MethodCallExpr($1, $3, $4); "); }
    | SUPER DOT IDENTIFIER actual_args { yydebug(" $$ = new SuperCallExpr($3, $4); "); }
    | array_expr { yydebug(" $$ = $1; "); }
    | field_expr { yydebug(" $$ = $1; "); }

field_expr
    : primary DOT IDENTIFIER { yydebug(" $$ = new fieldExpr($1, $3);"); }
    | SUPER DOT IDENTIFIER { yydebug(" $$ = new SuperfieldExpr($3); "); }

array_expr
    : IDENTIFIER dimension { yydebug(" $$ = new ArrayExpr(new IdPrimary( new DefaultTypebox(), $1), $2;) "); }
    | non_new_array_expr dimension { yydebug(" $$ = new ArrayExpr(new NonNewArrayPrimary( new DefaultTypebox(), $1), $2); "); }

literal
    : NILL { yyerror(" $$ = new NullLiteral(); "); }
    | BOOLEAN { yyerror(" $$ = new BoolLiteral($1); "); }
    | INTEGER { yydebug(" $$ = new IntLitA($1); "); $$ = new IntLitA($1); }
    | CHAR { yyerror(" $$ = new CharLiteral($1); "); }
    | STRING { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }

actual_args
    : OP expr_list CP { yydebug(" $$ = $2 "); }
    | OP CP { yydebug(" $$ = {} "); }

expr_list
    : expr COMMA expr_list { yydebug(" $$->push_back($1); "); }
    | expr { yydebug(" $$->push_back($1); "); }

%%

void yyerror(string s)
{
	// fprintf(stderr, "error: %s\n", s);
    cout << "XXXX error: " << s << " XXXXXXXXXXXXXXXXXXXXXXX\n";
}

void yydebug(string s) {
    // printf("%s", s);
    cout << "\t" << s << "\n";
}

int main(int argc, char **argv) {
    cout << "\n===[PARSING]===\n";

    yyin = fopen(argv[1], "r");
	yyparse();

    cout << "\n===[PRINTING]===\n";
    cout << "\n";
    start->accept(*(new PrinterV()));
    cout << "\n";

    // cout << "\n===[COUNTING]===\n";
    // cout << "\n";
    // start->accept(*(new CounterV()));
    // cout << "\n";

	return 0; 
} 