%{
#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>

#include "visitor/ast.cpp"


using namespace std;

extern "C" int yylex();
extern "C" int yyparse();
// extern "C" voIDENTIFIER yyerror(char *s); // lol
extern "C" void yyerror(string s);
extern "C" int yywrap(void){return 1;};

extern "C" void yydebug(string s);

extern FILE *yyin;

StartA* start;


%}


%token BREAK
%token CLASS
%token CONTINUE
%token ELSE
%token EXTENDS
%token IF
%token NEW
%token<s> PRIVATE
%token<s> PROTECTED
%token<s> PUBLIC
%token<s> RETURN
%token<s> STATIC
%token<s> SUPER
%token<s> TYPE_VOID
%token<s> TYPE_INT
%token<s> TYPE_BOOL
%token<s> TYPE_CHAR
%token THIS
%token WHILE
%token FORBIDDEN
%token UNENDED_COM
%token LEQ
%token LESS
%token GREATER
%token EQEQ
%token GEQ
%token EQ
%token NEQ
%token LAND
%token LOR
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token NOT
%token OP
%token CP
%token OB
%token CB
%token OC
%token CC
%token COMMA
%token DOT
%token SEMICOLON
%token<s> IDENTIFIER
%token NILL
%token BOOLEAN
%token INTEGER
%token STRING
%token CHAR
%token UNRECOG_ERROR
%token TYPER_INT
%token VOID

// %precedence NOT
// %left PLUS MINUS TIMES DIV MOD
// %right EQ
// %left LOR LAND
// %left LESS GREATER LEQ GEQ
// %left EQEQ NEQ
// %precedence UMINUS

%precedence NOT UMINUS UPLUS
%left       TIMES DIV MOD
%left       PLUS MINUS
%nonassoc   LESS GREATER LEQ GEQ
%left       EQEQ NEQ
%left       LAND
%left       LOR
%right      EQ
%right      IF
%right      LOWEST

%union{
    char*       s;
    int         i;
    double      d;
    bool        b;
    char        c;

    class AST*          ast;
    class ClassA*       classA;
    class StartA*       startA;
    class ListA*        listA;
    class FieldA*       fieldA;
    class MethodA*      methodA;
    class ConstructorA* constructorA;
    class StrLitA*      strLitA;
    class TypeA*        typeA;
    class PrimTypeA*    primTypeA;
    class FormalA*      formalA;
    class BlockA*       blockA;
}

// %type<s> 
%type<i>                bracket_list

%type<ast>              member
%type<classA>           single_class super
%type<listA>            member_list modifier_list formal_args formal_arg_list
%type<startA>           class_list
%type<fieldA>           field
%type<methodA>          method_decl
%type<constructorA>     ctor
%type<strLitA>          modifier 
%type<typeA>            type_decl
%type<primTypeA>        primitive_type
%type<formalA>          formal_arg
%type<blockA>           block


%%
class_list
    : single_class class_list { 
        yydebug(" $$ = $2; $$->add($1); "); 
        $$ = $2; $$->add($1);
    }
    | single_class { 
        yydebug(" $$ = new StartA(); $$->add($1); "); 
        $$ = new StartA(); $$->add($1);

        start = $$;
    }
    ;

single_class
    : CLASS IDENTIFIER OC CC { 
        yydebug(" $$ = new ClassA($2); ");
        $$ = new ClassA($2);
    }
    | CLASS IDENTIFIER super OC CC { 
        yydebug(" $$ = new ClassA($2, $3); "); 
        $$ = new ClassA($2, $3);
    }
    | CLASS IDENTIFIER OC member_list CC { 
        yydebug(" $$ = new ClassA($2, $4); "); 
        $$ = new ClassA($2, $4);
    }
    | CLASS IDENTIFIER super OC member_list CC { 
        yydebug(" $$ = new ClassA($2, $3, $5); "); 
        $$ = new ClassA($2, $3, $5);
    }
    ;

super
    : EXTENDS IDENTIFIER { yydebug(" $$ = new Super($2) "); }
    ;

member_list
    : member member_list { 
        yydebug(" $$ = $2; $$->add($1); "); 
        $$ = $2; $$->add($1);
    }
    | member { 
        yydebug(" $$ = new ListA(); $$->add($1); "); 
        $$ = new ListA(); $$->add($1);
    }
    ;

member
    : field { yydebug(" $$ = $1; "); $$ = $1; }
    | method_decl { yydebug(" $$ = $1; "); $$ = $1; }
    | ctor { yydebug(" $$ = $1; "); $$ = $1; }
    ;

field
    : modifier_list type_decl var_decl_list SEMICOLON  { yydebug(" <BLAH> "); }
    // { yydebug(" List.map \
    // (fun d -> Field($1, $2, d)) \
    // $3 "); }
    | type_decl var_decl_list SEMICOLON { yydebug(" <BLAH> "); }
    // { yydebug(" List.map \
    // (fun d -> \
    // Field([Public], $1, d)) $2 "); }
    ;

modifier_list
    : modifier modifier_list { 
        yydebug(" $$ = $2; $$->add($1); "); 
        $$ = $2; $$->add($1);
    }
    | modifier { 
        yydebug(" $$ = new ListA(); $$->add($1); "); 
        $$ = new ListA(); $$->add($1);
    }
    ;

method_decl
    : modifier_list type_decl IDENTIFIER formal_args block { 
        yydebug(" $$ = new MethodA($1, $2, $3, $4, new MethodBodyA($4, $5->getStatementList())); "); 
        $$ = new MethodA($1, $2, $3, $4, new MethodBodyA($4, $5->getStatementList()));
    }
    | type_decl IDENTIFIER formal_args block { 
        yydebug(" $$ = new MethodA($1, $2, $3, new MethodBodyA($3, $4->getStatementList())); "); 
        $$ = new MethodA($1, $2, $3, new MethodBodyA($3, $4->getStatementList()));
    }
    ;

ctor
    : modifier_list IDENTIFIER formal_args block { yydebug(" $$ = new Constructor(new ClassType($2), $1, $3, $4) "); }
    | IDENTIFIER formal_args block { yydebug(" $$ = new Constructor(new ClassType($1), \"public\", $2, $3); "); }
    ;

modifier
    : STATIC    { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }
    | PUBLIC    { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }
    | PRIVATE   { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }
    | PROTECTED { yydebug(" $$ = new StrLitA($1); "); $$ = new StrLitA($1); }
    ;

formal_args
    : OP formal_arg_list CP { yydebug(" $$ = $2; "); $$ = $2; }
    | OP CP { yydebug(" $$ = new ListA(); "); $$ = new ListA(); }
    ;

formal_arg_list
    : formal_arg COMMA formal_arg_list { 
        yydebug(" $$ = $3; $$->add($1); "); 
        $$ = $3; $$->add($1);
    }
    | formal_arg { 
        yydebug(" $$ = new ListA(); $$->add($1); "); 
        $$ = new ListA(); // $$->add($1); // TODO:
    }
    ;

formal_arg
    : type_decl var_decl_id { 
        yydebug(" $$ = new FormalA($1, $2); ?? "); // TODO:
    }
    ;

// TODO: make sure bracket_list binds properly 
//       want Arr(t, 2), not Arr(Arr(t, 1), 1)
type_decl   
    : primitive_type { 
        yydebug(" $$ = $1; "); 
        $$ = $1;
    }
    | IDENTIFIER { 
        yydebug(" $$ = new ClassTypeA($1); "); 
        $$ = new ClassTypeA($1); 
    }
    | type_decl bracket_list { 
        yydebug(" $$ = new ArrayTypeA($1, $2); "); 
        $$ = new ArrayTypeA($1, $2);
    }
    ;

bracket_list
    : OB CB bracket_list { yydebug(" $$ = ++$3; "); $$ = ++$3; }
    | OB CB { yydebug(" $$ = 1; "); $$ = 1; }
    ;

primitive_type
    : TYPE_BOOL { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }
    | TYPE_CHAR { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }
    | TYPE_INT  { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }
    | TYPE_VOID { yydebug(" $$ = new PrimTypeA($1); "); $$ = new PrimTypeA($1); }
    ;

var_decl_list
    : var_decl COMMA var_decl_list { yydebug(" $$->push_back($1); "); }
    | var_decl { yydebug("  $$->push_back($1); "); }
    ;

var_decl
    : var_decl_id EQ expr { yydebug("{ name = fst $1 ; dim = snd $1 ; expr = Some $3 }"); }
    | var_decl_id { yydebug("{ name = fst $1 ; dim = snd $1 ; expr = None }"); }
    ;

var_decl_id
    : var_decl_id OB CB { yydebug(" fst $1, snd $1 + 1 "); }
    | IDENTIFIER { yydebug(" $1, 0 "); }
    ;

block
    : OC statement_list CC { yydebug(" $$ = $2; "); }
    | OC CC { yydebug(" $$ = new BlockA(); "); $$ = new BlockA(); }
    ;

statement_list
    : statement statement_list { yydebug(" $$->push_back($1); "); }
    | statement { yydebug(" $$->push_back($1); "); }
    ;

statement
    : SEMICOLON { yydebug(" $$ =new EmptyStatement() "); }
    | type_decl var_decl_list SEMICOLON { yydebug(" $$ = new DeclStatement($1, $2) "); }
    | IF OP expr CP statement // { yydebug(" $$ = new If($3, $5, NULL); "); }
            %prec LOWEST { yydebug(" $$ = new If($3, $5, NULL); "); }
    | IF OP expr CP statement ELSE statement { yydebug(" $$ = new If($3, $5, $7); "); }
    | expr SEMICOLON { yydebug(" $$ = new ExprStatement($1); "); }
    | WHILE OP expr CP statement { yydebug(" $$ = new WhileStatement(new symbolTable(), $3, $5); "); }
    | RETURN SEMICOLON { yydebug(" $$ = new ReturnStatement(NULL); "); }
    | RETURN expr SEMICOLON { yydebug(" $$ = new ReturnStatement($2); "); }
    | CONTINUE SEMICOLON { yydebug(" $$ = new ContinueStatement(); "); }
    | BREAK SEMICOLON { yydebug(" $$ = new BreakStatement(); "); }
    | block { yydebug(" $$ = new Block($1); "); }
    | SUPER actual_args SEMICOLON { yydebug(" $$ = new SuperStatement($2); "); }
    ;

expr
    : expr EQ expr { yydebug("$$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr GREATER expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr LESS expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr EQEQ expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr GEQ expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr LEQ expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr NEQ expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr PLUS expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr MINUS expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr TIMES expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr DIV expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr LAND expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr LOR expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | expr MOD expr { yydebug(" $$ = new BinOpExpr(string($2), $1, $3); "); }
    | PLUS expr %prec UPLUS { yydebug(" $$ = new UnOpExpr(string($2), $2); "); }
    | MINUS expr %prec UMINUS { yydebug(" $$ = new UnOpExpr(string($2), $2); "); }
    | NOT expr { yydebug(" $$ = new UnOpExpr(string($2), $2); "); }
    | primary { yydebug(" $$ = new PrimaryExpr($1); "); }
    ;

primary
    : new_array_expr { yydebug(" $$ = new NewArrayPrimary( new defaultTypebox(), $1) "); }
    | non_new_array_expr { yydebug(" $$ = new NonNewArrayPrimary( new default_typebox(), $1) "); }
    | IDENTIFIER { yydebug(" $$ = new IdPrimary( new defaultTypebox(), $1); "); }
    ;

new_array_expr
    : NEW IDENTIFIER dimension_list { yydebug("{ t = ClassType($2) ; dimList = $3 }"); }
    | NEW primitive_type dimension_list { yydebug("{ t = $2 ; dimList = $3 }"); }
    ;

dimension_list
    : dimension dimension_list { yydebug(" $$->push_back($1); "); }
    | dimension { yydebug(" $$->push_back($1); "); }
    ;

dimension
    : OP expr CB { yydebug(" $$ = $2 "); }
    ;

non_new_array_expr
    : literal { yydebug(" $$ = new LiteralExpr($1) "); }
    | THIS { yydebug(" $$ = new ThisExpr(); "); }
    | OP expr CP { yydebug(" $$ = new ParenExpr($2); "); }
    | NEW IDENTIFIER actual_args { yydebug(" $$ = new NewObjExpr($2, $3); "); }
    | IDENTIFIER actual_args { yydebug(" $$ = new ThisCallExpr($1, $2); "); }
    | primary DOT IDENTIFIER actual_args { yydebug(" $$ = new MethodCallExpr($1, $3, $4); "); }
    | SUPER DOT IDENTIFIER actual_args { yydebug(" $$ = new SuperCallExpr($3, $4); "); }
    | array_expr { yydebug(" $$ = $1; "); }
    | field_expr { yydebug(" $$ = $1; "); }
    ;

field_expr
    : primary DOT IDENTIFIER { yydebug(" $$ = new fieldExpr($1, $3);"); }
    | SUPER DOT IDENTIFIER { yydebug(" $$ = new SuperfieldExpr($3); "); }
    ;

array_expr
    : IDENTIFIER dimension { yydebug(" $$ = new ArrayExpr(new IdPrimary( new DefaultTypebox(), $1), $2;) "); }
    | non_new_array_expr dimension { yydebug(" $$ = new ArrayExpr(new NonNewArrayPrimary( new DefaultTypebox(), $1), $2); "); }
    ;

literal
    : NILL { yydebug(" $$ = new NullLiteral(); "); }
    | BOOLEAN { yydebug(" $$ = new BoolLiteral($1); "); }
    | INTEGER { yydebug(" $$ = new IntLiteral($1); "); }
    | CHAR { yydebug(" $$ = new CharLiteral($1); "); }
    | STRING { yydebug(" $$ = new StringLiteral($1); "); }
    ;

actual_args
    : OP expr_list CP { yydebug(" $$ = $2 "); }
    | OP CP { yydebug(" $$ = {} "); }
    ;

expr_list
    : expr COMMA expr_list { yydebug(" $$->push_back($1); "); }
    | expr { yydebug(" $$->push_back($1); "); }
    ;

%%

void yyerror(string s)
{
	// fprintf(stderr, "error: %s\n", s);
    cout << "XXXX error: " << s << " XXXXXXXXXXXXXXXXXXXXXXX\n";
}

void yydebug(string s) {
    // printf("%s", s);
    cout << "\t" << s << "\n";
}

int main(int argc, char **argv) {
    cout << "\n===[PARSING]===\n";

    yyin = fopen(argv[1], "r");
	yyparse();

    cout << "\n===[PRINTING]===\n";
    cout << "\n";
    start->accept(*(new PrinterV()));
    cout << "\n";

    // cout << "\n===[COUNTING]===\n";
    // cout << "\n";
    // start->accept(*(new CounterV()));
    // cout << "\n";

	return 0; 
} 